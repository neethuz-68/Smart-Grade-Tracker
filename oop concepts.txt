OOP concepts to be implemented

Encapsulation
Encapsulation is the bundling of data (attributes) and the methods that operate on that data into a single unit (a class), while hiding the data from the outside world.
Project Example: Your Student class encapsulates student data. 
The attributes like name and email are private, so they can only be accessed through public methods (getters and setters). 
This protects the data from being accidentally corrupted. 
public class Student {
    private String name; // Data is private

    // Public method to access data
    public String getName() {
        return this.name;
    }
}


Abstraction
Abstraction is the concept of hiding complex implementation details and showing only the essential features of an object. 
It simplifies the system by reducing complexity.
Project Example: Your DatabaseManager class provides a perfect example of abstraction. 
The AuthController doesn't need to know the complex SQL queries or JDBC connection logic. 
It simply calls a high-level method to perform an action. 
This aligns with your architecture, where the "Backend" services hide the "Database" complexity. 
// AuthController only needs to know about this simple method...
Student user = dbManager.validateUser(username, password);
// ...it doesn't need to know the complex SQL code inside it.


Inheritance
Inheritance allows a new class to be based on an existing class, inheriting its properties and methods. 
This is crucial for reusing code and is the foundation of your GUI.
Project Example: Your View classes, like LoginView, must extend a built-in Java Swing class like JFrame.
By doing this, your LoginView automatically inherits all the properties and behaviors of a window (like a title bar, close buttons, and the ability to be displayed on screen), which is essential for creating your "user-friendly interface via Java Swing". 
import javax.swing.JFrame;
// LoginView IS-A JFrame, inheriting all its window functionality.
public class LoginView extends JFrame {
    // ...
}


Polymorphism
Polymorphism is the ability of an object to take on many forms. 
In your project, it's most clearly seen when you handle user actions.
Project Example: Both your AuthController (for the login button) and a future GradeController (for a "Save Grades" button) can implement the ActionListener interface. 
This means both will have an actionPerformed() method, but each will perform a different action. 
The Swing framework can treat both objects polymorphically as the same type (ActionListener), but the correct specific action will run depending on which button was clicked.
// Both controllers can be treated as the same type (ActionListener)
loginButton.addActionListener(authController);
saveGradesButton.addActionListener(gradeController);